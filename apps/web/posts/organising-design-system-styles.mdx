---
date: 2024-09-12
title: Configuring Tailwind as a Design System
lede: A brief description or introduction to your post.
assets:
  - src: /images/VIDEO-POSTER-TODO.png
    poster: /images/VIDEO-POSTER-TODO.png
    alt: Description of the main asset
    aspect: 1728-1080
category: writing
tags:
  - engineering
  - teamwork
  - featured
nextPostLink: iteration-and-prototyping
---

For design systems, consistency and comprehension are everything. A good design system ensures consistency of implementation through the configuration of code that implements it. It needs to be:

- easy to comprehend without foregoing the nuance that good design requires;
- scalable and maintainable without compromising consistency.

Here's my current approach to configuring design tokens and CSS classes relative to my default stack of [React](https://react.dev/) with [Tailwind](https://tailwindcss.com/). I'll start with a major criticism that I see all the time, and then breakdown a series of configuration steps that I use to solve it.[^1]

I'll show you how setting our own defaults for typography, colour and spacing is not only the starting point for differentiating your app's look and feel. More importantly, at the start of the process, it drastically cuts down on the number of classes we have to write and maintain and reduces the mental load of applying styles in a systematic, consistent and error-free way.

## Ease of use does not equate to ease of knowledge

Defaults are fantastic ways to advance systems. Zero config "it just works" libraries like Tailwind are the [infrastructure pace layer](https://jollycontrarian.com/index.php?title=Pace_layering) that creates more time for building. If that's what you need, don't read any further—the default CSS from Tailwind is more than fine.

But if you're scaling an app, and it needs to look good, then the governance layer underneath your "free of charge" infrastructure tools requires attention.

Tailwind makes it easy for developers to write styles. But that doesn't mean the outcome is good design or that the resulting use of code equates with a scalable, maintainable and comprehensive design system.

Often, devs run with the default Tailwind config and push style management to the application of classes on components. The organisation of these components within folders then becomes their design system, whether they mean it to or not. The result is many components each with a mess of classes that are hard to reason about.

<Img
  src="/images/post-ds-smush-01.png"
  alt="A smush of tailwind classes"
  aspect="1300-920"
  priority
/>

Above is a prime example. It is almost illegible. This makes it impossible to gain an understanding of the typography, color, spacing, responsiveness and color mode variations without significant effort.

It's easy to smush colour, typography, spacing, and responsiveness all together into a single class string. But there is no ease of knowledge here. Attempts at manipulating this "Prose" system are highly likely to lead to duplication and error, spiralling away from consistency relative to other styles throughout the app.

## Configure your system for ease of knowledge

Ease of use comes with trade-offs. By defering to an abstract standard someone else defined, we deferred to their knowhow. This can be beneficial, but it can also be a trap. Let's take a step back and think about what the basics of a design system consist of:

- typography
- colour
- spacing
- responsiveness (which includes color mode)

These, and many others, are set in the Tailwind config, which we can customise.

{/* prettier-ignore */}
```ts
const config = {
  theme: {
    fontSize: { /* ... */ },
    colors: { /* ... */ },
    spacing: { /* ... */ },
  },
};
```

### Typographic defaults

For example, we can set leading (line-height) and tracking (letter-spacing) as parameters for each font size tuple. This means we don't need to set leading or tracking when we use a font-size class. No need to remember (or fail to look up) what the line-height of small text is.

```ts
fontSize: {
  small: [
    "13px",
    { lineHeight: 1.5, letterSpacing: "0.015em" },
  ],
  base: [
    "16px",
    { lineHeight: 1.5, letterSpacing: 0 },
  ],
}
```

Using `text-small` now sets font-size, line-height and letter-spacing.

```jsx
/* 13px/1.5 with 0.015em letter-spacing */
<div className="text-small" />
```

### Color defaults

We can use CSS variables to set responsive colours under `:root` and `html.dark` scopes. This means we write and manage one class, such as `bg-canvas`, instead of two, such as `bg-gray-100 dark:bg-gray-800`.

```css
@import "@radix-ui/colors/gray.css";
@import "@radix-ui/colors/gray-dark.css";

:root {
  --color-gray-base: var(--gray-1);
  --color-gray-bg: var(--gray-3);
  --color-gray-line: var(--gray-4);
  --color-gray-border: var(--gray-5);
  --color-gray-solid: var(--gray-10);
  --color-gray-fill: var(--gray-12);
}
```

Because I'm using [Radix Colors](https://www.radix-ui.com/colors) here, I don't need to set the `.dark` scope as that's [already done for me](https://github.com/radix-ui/colors/blob/8a03dad3bc93ea4ed48ce2b70847a3538097e02f/scripts/build-css-modules.js#L19). Then set the CSS variables in the Tailwind config.

```ts
colors: {
  canvas: "var(--color-gray-base)",
  background: "var(--color-gray-bg)",
  line: "var(--color-gray-line)",
  border: "var(--color-gray-border)",
  solid: "var(--color-gray-solid)",
  fill: "var(--color-gray-fill-contrast)",
}
```

Using `bg-canvas` now sets the appropriate color in light or dark mode.

```jsx
/* sets --gray-1 as #fcfcfc on :root or #111111 on html.dark */
<div className="bg-canvas" />
```

And if you don't like the Radix colors, you can [customise them](https://www.radix-ui.com/colors/custom).

### Semantic naming

I advocate semantic names for colours and font-sizes because semantic naming is a forcing function that ties meaning to use to reduce error. How?

It is easier to remember the names for dark and light text colors when they are called `fill` and `solid`. It's harder and more error-prone when they're called `gray-900` and `gray-600` because then you have to remember specifically that it wasn't `gray-950` and `gray-500`, or `gray-800` and `gray-700`.

I've seen countless projects where inconsistent `gray-50`, `gray-100` or `gray-200` are all used for backgrounds. This is easily solved by defining a color called `background`.

But naming things—and agreeing on naming—is hard. In the spirit of zero-config, I suggest stealing [Radix Color](https://www.radix-ui.com/colors)'s backgrounds, borders, solids & fills paradigm. Or [this](https://github.com/rainbow-me/rainbowkit/blob/d8c64ee4baf865d3452a6b92e0525c123f680ec1/site/css/tokens.ts#L120) label, fill, background palette.

And once you've set this in `tailwind.config`, Typescript will jog your memory at your fingertips with autocomplete.

### Avoid namespace clashes

If you're [extending a Tailwind theme](https://tailwindcss.com/docs/plugins#extending-the-configuration) and not writing your own, don't use a scale key that's already been used. You may inadvertently overwrite a class that you need to use.

You'll note in the previous colour config example that I set the `--color-gray-base` var to `canvas`, not `base`. If I used `base` then using this color scale as a text colour (`text-base`) would clash with the [default font-size base value](https://github.com/tailwindlabs/tailwindcss/blob/818d10ab8461e682a185475dd4718e741103a4e3/stubs/config.full.js#L327), which is also `text-base`.

This isn't a downfall of customising the Tailwind config, it's a legacy of its theme naming: setting font-size or color classes in Tailwind both use `text-*`.[^2]

### Spacing defaults

We can also use CSS variables to set spacings.

```css
:root {
  --height-nav: 80px;
  --height-tab: 54px;
  --space-inset: 20px;
  --container-text-px: 660px;
  --container-hero-px: 1000px;
}
```

```ts
spacing: {
  em: "1em",
  nav: "var(--height-nav)",
  inset: "var(--space-inset)",
  text: "var(--container-text)",
  hero: "var(--container-hero)",
}
```

One could argue this is over-engineering. Except that when it comes time to compute complex interactive layouts like sticky headers, scroll margins and so on, this upfront configuration work makes it straight forward and error-free.

```jsx
<div className="top-[calc(theme(spacing.nav)+theme(spacing.tab))]">
  <div className="scroll-mt-[calc(theme(spacing.nav)+theme(spacing.tab))]">
    /* ... */
  </div>
</div>
```

Note again the use of semantic naming to make it easy to remember and use.

### Why em?

You'll notice in the prior spacing example that I set a "1em" value to an `em` key. I use this for child elements that should be related to the font-size of the parent. For example, icons.

```ts
<Text as="div" intent="heading" className="flex items-center gap-1">
  /* instead of "h-4 w-4" */
  <Icon className="size-em" />
  Heading copy
</Text>
```

Diagram example here?

Using em for inline relationships keeps the child element directly related to the parent's font-size. It's a simple, maintianable and error-free way to set relationships between elements that deletes the need to use `px` or `rem` units.

Ps. I'll talk about how I roll up typography tokens and styles into `<Text />` components with a constrained styling API in the post in this series.

## Augmenting your Tailwind config

THere's further steps we can take to reduce the number of classes we have to write and maintain. And one particular opinion that I hold we underestimate the importance of: that we think in pixels, not rems.

### Clamp() your classes

We can avoid setting responsive font-size classes by using clamp as a a font-size value in `tailwind.config`. Here's the [simple clamp function](https://github.com/callumflack/callum-website/blob/3746ca4eef7eaae1663e39584bb75a35e732ccf1/packages/config-tailwind/generate-clamp-size.ts#L7) I use.

```ts
fontSize: {
  title: [
    /* clamp(17px, 14.1429px + 0.5714vw, 21px) */
    generateClampSize(500, 1200, 17, 21),
    { lineHeight: lineHeight.body, letterSpacing: letterSpacing.meta },
  ];
}
```

So instead of writing `text-lg lg:text-xl xl:text-2xl 2xl:text-4xl` we can just write `text-title`. This saves a large amount of mental effort, errors and debugging time. (What size is `text-5xl` anyway? If you can't picture it, delete it).

```ts
/* 17px at 500px, 21px at 1200, fluidly calculated inbetween */
<h2 className="text-title">
  Heading copy
</h2>
```

We can also do this for spacing. I prefix with `d` for "dynamic" to differentiate it from the default Tailwind spacing scale.

```ts
spacing: {
  /* lower value is 2/3 of upper value */
  d4: generateClampSize(500, 1200, 10.5, 16),
  d8: generateClampSize(500, 1200, 21, 32),
  d16: generateClampSize(500, 1200, 43, 64),
  d24: generateClampSize(500, 1200, 64, 96),
  d64: generateClampSize(500, 1200, 171, 256),
}
```

This allows us to write `py-d24` instead of `py-16 md:py-20 lg:py-24`. This alleviates the weight of holding a range of website versions for each media-query in our minds. Instead it encourages us to picture fluidly repsonsive whitespace between layout elements where measurements don't matter as much as consistent relationships.

```ts
<main className="pt-d24 pb-d64 space-y-w8">
  <header className="container max-w-hero space-y-1">
    /* ... */
  </header>
  <article className="container space-y-2">
    /* ... */
  </article>
</main>
```

### Thinking in pixels

Pixels over REM. decipher.

Yes, you can hover to see the pixel values. But that breaks the rule of instant feedback. And why is that even there? If one is thinking in pixels then the immeediate value shoudl be pixels.

## Summary

If you're scaling your Tailwind styling system, and you want your app to feel and look good, then you should customise Tailwind to:

- use the Tailwind fontSize config to it's full capacity
- set color variables on `:root` and `.dark` to hoist color mode styles
- name color and spacing scales semantically to avoid inconsistent use
- use `clamp()` to hoist responsiveness into the config and write much less classes
- relate icons to text size with `size-em`

The obstacle to configuring consistency with Tailwind is accepting an upfront time cost. But that cost pays off when the team understands the system, is writing less code, when design errors start to just go away, and when it's easy to remember what tokens belong to what context "at our finger tips".

Ease of use might help you get started faster. But it does not necessarily lead to good design outcomes, nor does it equate to ease of knowledge within the system.

In the next post of this series, I'll describe how I use [Class Variance Authority](https://cva.style/docs) with React components to roll up these design tokens into a constrained styling API with semantic props.

<Note>

[^1]: CSS-in-JS libraries have recently hit limitations (performance overhead, complex set-ups, learning curves, SSR obstacles), but it might be that [Vanilla Extract](https://vanilla-extract.style/) or [StyleX](https://stylexjs.com/docs/learn/) futher improves these ideas I'll tackle. For now I won't directly address them as I've not yet used them. There are great benefits to stikcing with default systems that everyone knows!

[^2]: This is also why I dislike using [tailwind-merge](https://github.com/dcastil/tailwind-merge) to remove duplicate Tailwind classes in JSX. More often than not, I find it removing a `text-color` in favour of a `text-fontSize` when both are needed.

</Note>
